<?xml version="1.0" encoding="UTF-8"?>

<!-- This is an automatically generated file. -->
<Chapter Label="Chapter_twicon">
<Heading>Twisted Conjugacy</Heading>

<Section Label="Chapter_Twisted_Conjugacy_Section_Twisted_Conjugation_Action">
<Heading>Twisted Conjugation Action</Heading>

 Let <Math>G, H</Math> be groups and <Math>\varphi,\psi\colon H \to G</Math> group homomorphisms. Then the pair <Math>(\varphi,\psi)</Math> induces a (right) group action on <Math>G</Math> given by
 <Display>G \times H \to G\colon (g,h) \mapsto g \cdot h := \psi(h)^{-1} g\varphi(h).</Display>
 This group action is called <Emph><Math>(\varphi,\psi)</Math>-twisted conjugation</Emph>, and induces an equivalence relation on the group <Math>G</Math>. We say that <Math>g_1, g_2 \in G</Math> are <Math>(\varphi,\psi)</Math>-twisted conjugate, denoted by <Math>g_1 \sim_{\varphi,\psi} g_2</Math>, if and only if there exists some element <Math>h \in H</Math> such that <Math>g_1 \cdot h = g_2</Math>, or equivalently <Math>g_1 = \psi(h) g_2 \varphi(h)^{-1}</Math>.
 <P/>If <Math>\varphi\colon G \to G</Math> is an endomorphism of a group <Math>G</Math>, then by <Emph><Math>\varphi</Math>-twisted conjugacy</Emph> we mean <Math>(\varphi,\operatorname{id}_G)</Math>-twisted conjugacy. Most functions in this package will allow you to input a single endomorphism instead of a pair of homomorphisms. The "missing" endomorphism will automatically be assumed to be the identity mapping. Similarly, if a single group element is given instead of two, the second will be assumed to be the identity.
<ManSection Label="TwistedConjugationGroup">
  <Func Arg="hom1[, hom2]" Name="TwistedConjugation" />
 <Description>
 Implements the twisted conjugation (right) group action induced by the pair of homomorphisms ( <A>hom1</A>, <A>hom2</A> ) as a function.
 </Description>
</ManSection>


<ManSection Label="IsTwistedConjugateGroup">
  <Func Arg="hom1[, hom2], g1[, g2]" Name="RepresentativeTwistedConjugation" />
 <Description>
 Tests whether the elements <A>g1</A> and <A>g2</A> are twisted conjugate under the twisted conjugacy action of the pair of homomorphisms ( <A>hom1</A>, <A>hom2</A> ).
 <P />
 This function relies on the output of <C>RepresentativeTwistedConjugation</C>.
 Computes an element that maps <A>g1</A> to <A>g2</A> under the twisted conjugacy action of the pair of homomorphisms ( <A>hom1</A>, <A>hom2</A> ) or returns <K>fail</K> if no such element exists.
 <P />
 If <Math>G</Math> is abelian, this function relies on (a generalisation of) <Cite Key='dt21-a' Where='Alg. 4'/>.
 If <Math>H</Math> is finite, it relies on a stabiliser-orbit algorithm.
 Otherwise, it relies on a mixture of the algorithms described in <Cite Key='roma16-a' Where='Thm. 3'/>, <Cite Key='bkl20-a' Where='Sec. 5.4'/>, <Cite Key='roma21-a' Where='Sec. 7'/> and <Cite Key='dt21-a' Where='Alg. 6'/>.
 </Description>
</ManSection>


<Example><![CDATA[
gap> G := AlternatingGroup( 6 );;
gap> H := SymmetricGroup( 5 );;
gap> phi := GroupHomomorphismByImages( H, G, [ (1,2)(3,5,4), (2,3)(4,5) ],
>  [ (1,2)(3,4), () ] );;
gap> psi := GroupHomomorphismByImages( H, G, [ (1,2)(3,5,4), (2,3)(4,5) ],
>  [ (1,4)(3,6), () ] );;
gap> tc := TwistedConjugation( phi, psi );;
gap> g1 := (4,6,5);;
gap> g2 := (1,6,4,2)(3,5);;
gap> IsTwistedConjugate( psi, phi, g1, g2 );
false
gap> h := RepresentativeTwistedConjugation( phi, psi, g1, g2 );
(1,2)
gap> tc( g1, h ) = g2;
true
]]></Example>


</Section>


<Section Label="Chapter_Twisted_Conjugacy_Section_Reidemeister_Classes">
<Heading>Reidemeister Classes</Heading>

 The equivalence classes of the equivalence relation <Math>\sim_{\varphi,\psi}</Math> are called the <Emph>Reidemeister classes of <Math>(\varphi,\psi)</Math></Emph> or the <Emph><Math>(\varphi,\psi)</Math>-twisted conjugacy classes</Emph>. We denote the Reidemeister class of <Math>g \in G</Math> by <Math>[g]_{\varphi,\psi}</Math>. The number of Reidemeister classes is called the Reidemeister number <Math>R(\varphi,\psi)</Math> and is always a positive integer or infinity.
<ManSection Label="ReidemeisterClassGroup">
  <Func Arg="hom1[, hom2], g" Name="ReidemeisterClass" />
  <Func Arg="hom1[, hom2], g" Name="TwistedConjugacyClass" />
 <Description>
 If <A>hom1</A> and <A>hom2</A> are group homomorphisms from  a group H to a group G, this method creates the Reidemeister class of the pair (<A>hom1</A>, <A>hom2</A>) with representative <A>g</A>. The following attributes and operations are available:
<List>
<Item>
<C>Representative</C>, which returns <A>g</A>,
</Item>
<Item>
<C>GroupHomomorphismsOfReidemeisterClass</C>, which returns the list [ <A>hom1</A>, <A>hom2</A> ],
</Item>
<Item>
<C>ActingDomain</C>, which returns the group H,
</Item>
<Item>
<C>FunctionAction</C>, which returns the twisted conjugacy action on G,
</Item>
<Item>
<C>Random</C>, which returns a random element belonging to the Reidemeister class,
</Item>
<Item>
<C>\in</C>, which can be used to test if an element belongs to the Reidemeister class,
</Item>
<Item>
<C>List</C>, which lists all elements in the Reidemeister class if there are finitely many, otherwise returns <K>fail</K>,
</Item>
<Item>
<C>Size</C>, which gives the number of elements in the Reidemeister class,
</Item>
<Item>
<C>StabiliserOfExternalSet</C>, which gives the stabiliser of the Reidemeister class under the twisted conjugacy action.
</Item>
</List>
<P/>
 </Description>
</ManSection>


<ManSection Label="ReidemeisterClassesGroup">
  <Func Arg="hom1[, hom2]" Name="ReidemeisterClasses" />
  <Func Arg="hom1[, hom2]" Name="TwistedConjugacyClasses" />
 <Description>
 Returns a list containing the Reidemeister classes of ( <A>hom1</A>, <A>hom2</A> ) if the Reidemeister number <Math>R( <A>hom1</A>, <A>hom2</A> )</Math> is finite, or returns <K>fail</K> otherwise. It is guaranteed that the Reidemeister class of the identity is in the first position.
 <P />
 If <Math>G</Math> is abelian, this function relies on (a generalisation of) <Cite Key='dt21-a' Where='Alg. 5'/>.
 If <Math>G</Math> and <Math>H</Math> are finite and <Math>G</Math> is not abelian, it relies on an orbit-stabiliser algorithm.
 Otherwise, it relies on (variants of) <Cite Key='dt21-a' Where='Alg. 7'/>.
 <P/>
 This function is only guaranteed to produce a result if either <Math>G = H</Math> or <Math>G</Math> is nilpotent-by-finite.
<P/>
 </Description>
</ManSection>


<ManSection Label="RepresentativesReidemeisterClassesGroup">
  <Func Arg="hom1[, hom2]" Name="RepresentativesReidemeisterClasses" />
  <Func Arg="hom1[, hom2]" Name="RepresentativesTwistedConjugacyClasses" />
 <Description>
 Returns a list containing representatives of the Reidemeister classes of ( <A>hom1</A>, <A>hom2</A> ) if the Reidemeister number <Math>R( <A>hom1</A>, <A>hom2</A> )</Math> is finite, or returns <K>fail</K> otherwise. It is guaranteed that the identity is in the first position.
 <P />
 The same remarks as for <C>ReidemeisterClasses</C> are valid here.
<P/>
 </Description>
</ManSection>


<ManSection Label="ReidemeisterNumberGroup">
  <Func Arg="hom1[, hom2]" Name="ReidemeisterNumber" />
  <Func Arg="hom1[, hom2]" Name="NrTwistedConjugacyClasses" />
 <Description>
 Returns the Reidemeister number of ( <A>hom1</A>, <A>hom2</A> ), i.e. the number of Reidemeister classes.
 <P />
 If <Math>G</Math> is abelian, this function relies on (a generalisation of) <Cite Key='jian83-a' Where='Thm. 2.5'/>.
 If <Math>G = H</Math>, <Math>G</Math> is finite non-abelian and <Math>\psi = \operatorname{id}_G</Math>, it relies on <Cite Key='fh94-a' Where='Thm. 5'/>.
 Otherwise, it uses the output of <C>ReidemeisterClasses</C>.
 <P />
 This function is only guaranteed to produce a result if either <Math>G = H</Math> or <Math>G</Math> is nilpotent-by-finite.
<P/>
 </Description>
</ManSection>


<Example><![CDATA[
gap> tcc := ReidemeisterClass( phi, psi, g1 );
(4,6,5)^G
gap> Representative( tcc );
(4,6,5)
gap> GroupHomomorphismsOfReidemeisterClass( tcc );
[ [ (1,2)(3,5,4), (2,3)(4,5) ] -> [ (1,2)(3,4), () ],
[ (1,2)(3,5,4), (2,3)(4,5) ] -> [ (1,4)(3,6), () ] ]
gap> ActingDomain( tcc ) = H;
true
gap> FunctionAction( tcc )( g1, h );
(1,6,4,2)(3,5)
gap> Random( tcc ) in tcc;
true
gap> List( tcc );
[ (4,6,5), (1,6,4,2)(3,5) ]
gap> Size( tcc );
2
gap> StabiliserOfExternalSet( tcc );
Group([ (1,2,3,4,5), (1,3,4,5,2) ])
gap> ReidemeisterClasses( phi, psi ){[1..7]};
[ ()^G, (4,5,6)^G, (4,6,5)^G, (3,4)(5,6)^G, (3,4,5)^G, (3,4,6)^G, (3,5,4)^G ]
gap> RepresentativesReidemeisterClasses( phi, psi ){[1..7]};
[ (), (4,5,6), (4,6,5), (3,4)(5,6), (3,4,5), (3,4,6), (3,5,4) ]
gap> NrTwistedConjugacyClasses( phi, psi );
184
]]></Example>


</Section>


<Section Label="Chapter_Twisted_Conjugacy_Section_Reidemeister_Spectra">
<Heading>Reidemeister Spectra</Heading>

 The set of all Reidemeister numbers of automorphisms is called the <Emph>Reidemeister spectrum</Emph> and is denoted by <Math>\operatorname{Spec}_R(G)</Math>, i.e.
 <Display>\operatorname{Spec}_R(G) := \{\, R(\varphi) \mid \varphi \in \operatorname{Aut}(G) \,\}.</Display>
 The set of all Reidemeister numbers of endomorphisms is called the <Emph>extended Reidemeister spectrum</Emph> and is denoted by <Math>\operatorname{ESpec}_R(G)</Math>, i.e.
 <Display>\operatorname{ESpec}_R(G) := \{\, R(\varphi) \mid \varphi \in \operatorname{End}(G) \,\}.</Display>
 The set of all Reidemeister numbers of pairs of homomorphisms from a group <Math>H</Math> to a group <Math>G</Math> is called the <Emph>coincidence Reidemeister spectrum</Emph> of <Math>H</Math> and <Math>G</Math> and is denoted by <Math>\operatorname{CSpec}_R(H,G)</Math>, i.e.
 <Display>\operatorname{CSpec}_R(H,G) := \{\, R(\varphi, \psi) \mid \varphi,\psi \in \operatorname{Hom}(H,G) \,\}.</Display>
 If <A>H</A> = <A>G</A> this is also denoted by <Math>\operatorname{CSpec}_R(G)</Math>.
 The set of all Reidemeister numbers of pairs of homomorphisms from every group <Math>H</Math> to a group <Math>G</Math> is called the <Emph>total Reidemeister spectrum</Emph> and is denoted by <Math>\operatorname{TSpec}_R(G)</Math>, i.e.
 <Display>\operatorname{TSpec}_R(G) := \bigcup_{H} \operatorname{CSpec}_R(H,G).</Display>
 <P/>
 Please note that the functions below are only implemented for finite groups.
<ManSection>
  <Func Arg="G" Name="ReidemeisterSpectrum" />
 <Description>
 Returns the Reidemeister spectrum of <A>G</A>.
 <P />
 If <Math>G</Math> is abelian, this function relies on the results from <Cite Key='send23-a'/>.
 </Description>
</ManSection>


<ManSection>
  <Func Arg="G" Name="ExtendedReidemeisterSpectrum" />
 <Description>
 Returns the extended Reidemeister spectrum of <A>G</A>.
 </Description>
</ManSection>


<ManSection>
  <Func Arg="[H, ]G" Name="CoincidenceReidemeisterSpectrum" />
 <Description>
 Returns the coincidence Reidemeister spectrum of <A>H</A> and <A>G</A>.
 </Description>
</ManSection>


<ManSection>
  <Func Arg="G" Name="TotalReidemeisterSpectrum" />
 <Description>
 Returns the total Reidemeister spectrum of <A>G</A>.
 </Description>
</ManSection>


<Example><![CDATA[
gap> Q := QuaternionGroup( 8 );;
gap> D := DihedralGroup( 8 );;
gap> ReidemeisterSpectrum( Q );
[ 2, 3, 5 ]
gap> ExtendedReidemeisterSpectrum( Q );
[ 1, 2, 3, 5 ]
gap> CoincidenceReidemeisterSpectrum( Q );
[ 1, 2, 3, 4, 5, 8 ]
gap> CoincidenceReidemeisterSpectrum( D, Q );
[ 4, 8 ]
gap> CoincidenceReidemeisterSpectrum( Q, D );
[ 2, 3, 4, 6, 8 ]
gap> TotalReidemeisterSpectrum( Q );
[ 1, 2, 3, 4, 5, 6, 8 ]
]]></Example>


</Section>


<Section Label="Chapter_Twisted_Conjugacy_Section_Reidemeister_Zeta_Functions">
<Heading>Reidemeister Zeta Functions</Heading>

 Let <Math>\varphi,\psi\colon G \to G</Math> be endomorphisms such that <Math>R(\varphi^n,\psi^n) &lt; \infty</Math> for all <Math>n \in \mathbb{N}</Math>. Then the <Emph>Reidemeister zeta function</Emph> <Math>Z_{\varphi,\psi}(s)</Math> of the pair <Math>(\varphi,\psi)</Math> is defined as
 <Display>Z_{\varphi,\psi}(s) := \exp \sum_{n=1}^\infty \frac{R(\varphi^n,\psi^n)}{n} s^n.</Display>
 <P/>
 Please note that the functions below are only implemented for endomorphisms of finite groups.
<ManSection Label="ReidemeisterZetaCoefficientsGroup">
  <Func Arg="endo1[, endo2]" Name="ReidemeisterZetaCoefficients" />
 <Description>
 For a finite group, the sequence of Reidemeister numbers of the iterates of <A>endo1</A> and <A>endo2</A>, i.e. the sequence <Math>R(<A>endo1</A>,<A>endo2</A>)</Math>, <Math>R(<A>endo1</A>^2,<A>endo2</A>^2)</Math>, ..., is eventually periodic, i.e. there exist a periodic sequence <Math>(P_n)_{n \in \mathbb{N}}</Math> and an eventually zero sequence <Math>(Q_n)_{n \in \mathbb{N}}</Math> such that
 <Display>\forall n \in \mathbb{N}: R(\varphi^n,\psi^n) = P_n + Q_n.</Display>
 This function returns a list containing two sublists: the first sublist contains one period of the sequence <Math>(P_n)_{n \in \mathbb{N}}</Math>, the second sublist contains <Math>(Q_n)_{n \in \mathbb{N}}</Math> up to the part where it becomes the constant zero sequence.
 </Description>
</ManSection>


<ManSection Label="IsRationalReidemeisterZetaGroup">
  <Func Arg="endo1[, endo2]" Name="IsRationalReidemeisterZeta" />
 <Description>
 Returns <K>true</K> if the Reidemeister zeta function of <A>endo1</A> and <A>endo2</A> is rational, and <K>false</K> otherwise.
 </Description>
</ManSection>


<ManSection Label="ReidemeisterZetaGroup">
  <Func Arg="endo1[, endo2]" Name="ReidemeisterZeta" />
 <Description>
 Returns the Reidemeister zeta function of <A>endo1</A> and <A>endo2</A> if it is rational, and <K>fail</K> otherwise.
 </Description>
</ManSection>


<ManSection Label="PrintReidemeisterZetaGroup">
  <Func Arg="endo1[, endo2]" Name="PrintReidemeisterZeta" />
 <Description>
 Returns a string describing the Reidemeister zeta function of <A>endo1</A> and <A>endo2</A>. This is often more readable than evaluating <C>ReidemeisterZeta</C> in an indeterminate, and does not require rationality.
 </Description>
</ManSection>


<Example><![CDATA[
gap> khi := GroupHomomorphismByImages( G, G, [ (1,2,3,4,5), (4,5,6) ],
>  [ (1,2,6,3,5), (1,4,5) ] );;
gap> ReidemeisterZetaCoefficients( khi );
[ [ 7 ], [  ] ]
gap> IsRationalReidemeisterZeta( khi );
true
gap> ReidemeisterZeta( khi );
function( s ) ... end
gap> s := Indeterminate( Rationals, "s" );;
gap> ReidemeisterZeta( khi )(s);
(1)/(-s^7+7*s^6-21*s^5+35*s^4-35*s^3+21*s^2-7*s+1)
gap> PrintReidemeisterZeta( khi );
"(1-s)^(-7)"
]]></Example>


</Section>


</Chapter>

