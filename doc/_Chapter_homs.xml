<?xml version="1.0" encoding="UTF-8"?>

<!-- This is an automatically generated file. -->
<Chapter Label="Chapter_homs">
<Heading>Homomorphisms</Heading>

<Section Label="Chapter_Homomorphisms_Section_Representatives_of_homomorphisms_between_groups">
<Heading>Representatives of homomorphisms between groups</Heading>

 Please note that the functions below are only implemented for finite groups.
<ManSection>
  <Func Arg="G" Name="RepresentativesAutomorphismClasses" />
 <Description>
 Let <A>G</A> be a group. This command returns a list of the automorphisms of <A>G</A> up to composition with inner automorphisms.
 </Description>
</ManSection>


<ManSection>
  <Func Arg="G" Name="RepresentativesEndomorphismClasses" />
 <Description>
 Let <A>G</A> be a group. This command returns a list of the endomorphisms of <A>G</A> up to composition with inner automorphisms.
 This does the same as calling <C>AllHomomorphismClasses(<A>G</A>,<A>G</A>)</C>, but should be faster for abelian and non-2-generated groups.
 For 2-generated groups, this function takes its source code from <C>AllHomomorphismClasses</C>.
 </Description>
</ManSection>


<ManSection>
  <Func Arg="H, G" Name="RepresentativesHomomorphismClasses" />
 <Description>
 Let <A>G</A> and <A>H</A> be groups. This command returns a list of the homomorphisms from <A>H</A> to <A>G</A>, up to composition with inner automorphisms of <A>G</A>.
 This does the same as calling <C>AllHomomorphismClasses(<A>H</A>,<A>G</A>)</C>, but should be faster for abelian and non-2-generated groups.
 For 2-generated groups, this function takes its source code from <C>AllHomomorphismClasses</C>.
 </Description>
</ManSection>


<Example><![CDATA[
gap> G := SymmetricGroup( 6 );;
gap> Auts := RepresentativesAutomorphismClasses( G );;
gap> Size( Auts );
2
gap> ForAll( Auts, IsGroupHomomorphism and IsEndoMapping and IsBijective );
true
gap> Ends := RepresentativesEndomorphismClasses( G );;
gap> Size( Ends );
6
gap> ForAll( Ends, IsGroupHomomorphism and IsEndoMapping );
true
gap> H := SymmetricGroup( 5 );;
gap> Homs := RepresentativesHomomorphismClasses( H, G );;
gap> Size( Homs );
6
gap> ForAll( Homs, IsGroupHomomorphism );
true
]]></Example>


</Section>


<Section Label="Chapter_Homomorphisms_Section_Coincidence_and_Fixed_Point_Groups">
<Heading>Coincidence and Fixed Point Groups</Heading>

<ManSection>
  <Func Arg="endo" Name="FixedPointGroup" />
 <Description>
 Let <A>endo</A> be an endomorphism of a group G. This command returns the subgroup of G consisting of the elements fixed under the endomorphism <A>endo</A>.
 <P />
 This function does the same as <C>CoincidenceGroup</C>(<A>endo</A>,<Math>\operatorname{id}_G</Math>).
 </Description>
</ManSection>


<ManSection>
  <Func Arg="hom1, hom2[, ...]" Name="CoincidenceGroup" />
 <Description>
 Let <A>hom1</A>, <A>hom2</A>, ... be group homomorphisms from a group H to a group G. This command returns the subgroup of H consisting of the elements h for which h^<A>hom1</A> = h^<A>hom2</A> = ...
 <P />
 For infinite non-abelian groups, this function relies on a mixture of the algorithms described in <Cite Key='roma16-a' Where='Thm. 2'/>, <Cite Key='bkl20-a' Where='Sec. 5.4'/> and <Cite Key='roma21-a' Where='Sec. 7'/>.
 </Description>
</ManSection>


<Example><![CDATA[
gap> phi := GroupHomomorphismByImages( G, G, [ (1,2,5,6,4), (1,2)(3,6)(4,5) ],
>  [ (2,3,4,5,6), (1,2) ] );;
gap> Set( FixedPointGroup( phi ) );
[ (), (1,2,3,6,5), (1,3,5,2,6), (1,5,6,3,2), (1,6,2,5,3) ]
gap> psi := GroupHomomorphismByImages( H, G, [ (1,2,3,4,5), (1,2) ],
>  [ (), (1,2) ] );;
gap> khi := GroupHomomorphismByImages( H, G, [ (1,2,3,4,5), (1,2) ],
>  [ (), (1,2)(3,4) ] );;
gap> CoincidenceGroup( psi, khi ) = AlternatingGroup( 5 );
true
]]></Example>


</Section>


<Section Label="Chapter_Homomorphisms_Section_Induced_and_restricted_group_homomorphisms">
<Heading>Induced and restricted group homomorphisms</Heading>

<ManSection>
  <Func Arg="epi1, epi2, hom" Name="InducedHomomorphism" />
 <Description>
 Let <A>hom</A> be a group homomorphism from a group H to a group G, let <A>epi1</A> be an epimorphism from H to a group Q and let <A>epi2</A> be an epimorphism from G to a group P such that the kernel of <A>epi1</A> is mapped into the kernel of <A>epi2</A> by <A>hom</A>. This command returns the homomorphism from Q to P induced by <A>hom</A> via <A>epi1</A> and <A>epi2</A>, that is, the homomorphism from Q to P which maps h<C>^<A>epi1</A></C> to <C>(</C>h<C>^<A>hom</A>)^<A>epi2</A></C>, for any element h of H. This generalises <C>InducedAutomorphism</C> to homomorphisms.
 </Description>
</ManSection>


<ManSection>
  <Func Arg="hom, N, M" Name="RestrictedHomomorphism" />
 <Description>
 Let <A>hom</A> be a group homomorphism from a group H to a group G, and let <A>N</A> be subgroup of H such that its image under <A>hom</A> is a subgroup of <A>M</A>. This command returns the homomorphism from N to M induced by <A>hom</A>. This is similar to <C>RestrictedMapping</C>, but the range is explicitly set to <A>M</A>.
 </Description>
</ManSection>


<Example><![CDATA[
gap> G := PcGroupCode( 1018013, 28 );;
gap> phi := GroupHomomorphismByImages( G, G, [ G.1, G.3 ],
>  [ G.1*G.2*G.3^2, G.3^4 ] );;
gap> N := DerivedSubgroup( G );;
gap> p := NaturalHomomorphismByNormalSubgroup( G, N );
[ f1, f2, f3 ] -> [ f1, f2, <identity> of ... ]
gap> ind := InducedHomomorphism( p, p, phi );
[ f1 ] -> [ f1*f2 ]
gap> Source( ind ) = Range( p ) and Range( ind ) = Range( p );
true
gap> res := RestrictedHomomorphism( phi, N, N );
[ f3 ] -> [ f3^4 ]
gap> Source( res ) = N and Range( res ) = N;
true
]]></Example>


</Section>


</Chapter>

